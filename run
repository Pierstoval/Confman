#!/usr/bin/env php
<?php

/**
 * This file is part of the Confman project.
 *
 * (c) Alex "Pierstoval" Rock <pierstoval@gmail.com>
 *
 * This source file is subject to the AGPL-3.0 license that is bundled
 * with this source code in the file LICENSE
 */

use Symfony\Component\Console\Application;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Cursor;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputDefinition;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\Process\ExecutableFinder;
use Symfony\Component\PropertyInfo\Extractor\PhpDocExtractor;
use Symfony\Component\PropertyInfo\Extractor\ReflectionExtractor;
use Symfony\Component\PropertyInfo\PropertyInfoExtractor;
use Symfony\Component\Serializer\Encoder\JsonEncode;
use Symfony\Component\Serializer\Encoder\JsonEncoder;
use Symfony\Component\Serializer\Exception\ExceptionInterface;
use Symfony\Component\Serializer\Mapping\Factory\ClassMetadataFactory;
use Symfony\Component\Serializer\Mapping\Loader\AttributeLoader;
use Symfony\Component\Serializer\NameConverter\MetadataAwareNameConverter;
use Symfony\Component\Serializer\Normalizer\ArrayDenormalizer;
use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
use Symfony\Component\Serializer\Serializer;

require __DIR__.'/vendor/autoload.php';

$PHPBIN = PHP_BINARY;

const APP_VERSION = 'v0.1.9';

class App extends Application {
    public readonly Serializer $serializer;
    public ?string $configFilePath;
    public ?GlobalConfig $config;
    private SymfonyStyle $io;

    public function __construct()
    {
        parent::__construct('Confman', APP_VERSION);
        $this->serializer = new Serializer([new ObjectNormalizer(classMetadataFactory: $metadataFactory = new ClassMetadataFactory(new AttributeLoader()), nameConverter: new MetadataAwareNameConverter($metadataFactory), propertyTypeExtractor: new PropertyInfoExtractor([], [new PhpDocExtractor(), new ReflectionExtractor()])), new ArrayDenormalizer()], [new JsonEncoder(defaultContext: [JsonEncode::OPTIONS => JSON_PRETTY_PRINT|JSON_UNESCAPED_SLASHES])]);
    }

    public function getGlobalConfig(?string $path = null): GlobalConfig
    {
        if (isset($this->config)) {
            return $this->config;
        }

        $path = $this->getProjectsFile($path);

        return $this->config = $this->serializer->deserialize(
            data: file_get_contents($path),
            type: GlobalConfig::class,
            format: 'json',
        );
    }

    public function findExecutable(string $command): string
    {
        static $finder;
        if (!$finder) {
            $finder = new ExecutableFinder();
        }
        $executable = $finder->find($command);
        if (!$executable) {
            throw new \RuntimeException(sprintf('Could not find "%s" command. Did you install it in your system?', $command));
        }
        return $executable;
    }

    public function saveProjects(GlobalConfig $projects): void
    {
        $json = $this->serializer->serialize(
            data: $projects,
            format: 'json',
        );

        file_put_contents($this->configFilePath, $json);
    }

    public function getProjectsFile(?string $inputPath = null): string
    {
        if (isset($this->configFilePath)) {
            return $this->configFilePath;
        }

        $allowedPaths = $this->getAllowedConfigPaths($inputPath);

        foreach ($allowedPaths as $p) {
            if (is_file($p)) {
                $this->configFilePath = $p;
                $this->io->section(sprintf("Detected config file at <info>%s</>", $p));
                return $p;
            }
        }

        $error = trim(sprintf(
            <<<ERR
            Config manager file was not found.
            Searched in these paths:
            %s
            ERR
            ,
            implode("\n", array_map(static fn (string $path) => sprintf($inputPath ? ' - %s' : ' - <info>%s</>', $path), $allowedPaths))
        ));

        if ($inputPath) {
            $this->io->error($error);
        } else {
            $error .= "\n\nCreate any of these files to start configuring your setup ðŸš€";

            $this->io->writeln(sprintf("\n<comment> %s</>\n", str_replace("\n", "\n ", $error)));
        }

        exit(2);
    }

    public function getAllowedConfigPaths(?string $inputPath = null): array
    {
        $allowedPaths = [];

        if ($inputPath) {
            if (file_exists($inputPath)) {
                $allowedPaths[] = $inputPath;
            }
            if (!str_ends_with($inputPath, '.json')) {
                $allowedPaths[] = getcwd().'/'.rtrim($inputPath, '\\/').'.json';
            }
        }
        if ($inputPath && is_dir($inputPath)) {
            $allowedPaths[] = $inputPath . '/confman.json';
        }

        if ($inputPath && ($_SERVER['HOME'] ?? '') && !is_file($inputPath) && !str_contains($inputPath, '/\\')) {
            $testPath = rtrim($_SERVER['HOME'], '\\/').'/.config/Confman/'.$inputPath.'.json';
            $allowedPaths[] = $testPath;
        }

        if (!$inputPath) {
            $allowedPaths[] = __DIR__ . '/confman.json';
        }
        if (!$inputPath && ($cwd = getcwd()) !== false && $cwd !== __DIR__) {
            $allowedPaths[] = rtrim($cwd, '\\/') . '/confman.json';
        }
        if (!$inputPath && ($_SERVER['HOME'] ?? '')) {
            $allowedPaths[] = rtrim($_SERVER['HOME'], '\\/').'/.config/Confman/confman.json';
        }

        return $allowedPaths;
    }

    public function executeCommandOnProject(Project $project, array $command): string
    {
        $process = new Symfony\Component\Process\Process($command, $project->path);
        $process->run();

        return trim($process->getOutput(), " \n\r\t\v\0'\"");
    }

    public function executeCommandOnAllProjects(array $command, Cursor $cursor): void {
        $globalConfig = $this->getGlobalConfig();

        $rows = [];
        $processes = [];
        $errors = [];

        $this->io->section(sprintf('Running <info>%s</> on all projectsâ€¦', implode(' ', $command)));

        $renderRows = fn ($rows) => $this->io->table(['Project', 'Path', 'Status'], $rows);

        $render = static function($rows) use ($cursor, $renderRows) {
            foreach ($rows as $row) {
                $cursor->moveUp();
            }
            $cursor->moveUp(5); // Last line, headers, and table separators
            $cursor->moveToColumn(0);
            $renderRows($rows);
        };

        foreach ($globalConfig->projects as $project) {
            $rows[$project->name] = [$project->name, $project->path, '-'];
        }
        $renderRows($rows);

        foreach ($globalConfig->projects as $project) {
            $rows[$project->name] = [$project->name, $project->path, 'Command startedâ€¦'];
            $process = new Symfony\Component\Process\Process($command, $project->path);
            $process->start();
            $processes[$project->name] = $process;
        }
        $render($rows);

        while (\count($processes) > 0) {
            foreach ($processes as $projectName => $process) {
                $project = $globalConfig->getProject($projectName);
                $refresh = false;
                if ($process->isSuccessful()) {
                    $rows[$projectName] = [$projectName, $project->path, str_pad('âœ…', 17, ' ', STR_PAD_BOTH)];
                    unset($processes[$projectName]);
                    $refresh = true;
                } elseif ($process->isTerminated() && $process->getExitCode() !== 0) {
                    $rows[$projectName] = [$projectName, $project->path, sprintf("âŒ Error %s %s", $process->getExitCode(), $process->getExitCodeText())];
                    $refresh = true;
                    unset($processes[$projectName]);
                    $errors[$projectName] = \trim($process->getOutput()."\n".$process->getErrorOutput());
                }
                if ($refresh) {
                    $render($rows);
                }
            }
        }

        if (!count($errors)) {
            $this->io->success('Done!');
        } else {
            foreach ($errors as $projectName => $message) {
                $message = \trim($message);
                $this->io->error(['Error in '.$projectName, ...[$message ? [$message] : []]]);
            }
        }
    }

    protected function getDefaultInputDefinition(): InputDefinition
    {
        $def = parent::getDefaultInputDefinition();

        $def->addOption(new InputOption('config', 'c', InputOption::VALUE_OPTIONAL, 'Path to look for the "confman.json" file. Can be a file or a directory.'));

        return $def;
    }

    protected function doRunCommand(Command $command, InputInterface $input, OutputInterface $output): int
    {
        $this->io = new SymfonyStyle($input, $output);

        if (
            $command->getName() !== 'projects:create'
            && $input->hasOption('config')
            && $input->getOption('config')
        ) {
            $this->getProjectsFile($input->getOption('config'));
        }

        return parent::doRunCommand($command, $input, $output);
    }
}

$app = new App();

$app->addCommand(new Command('projects:list')
    ->setAliases(['projects'])
    ->setDescription('Lists all currently configured projects')
    ->setCode(function (SymfonyStyle $io, Application $app): int {
    /** @var App $app */

    $projects = $app->getGlobalConfig();

    $io->table(
        ['Name', 'Path', 'Current branch', 'Last commit date', 'Current remote URL'],
        array_map(static function (Project $project) use ($app) {
            $currentBranch = $app->executeCommandOnProject($project, ['git', 'branch', '--show-current']);
            $lastCommitDate = $app->executeCommandOnProject($project, ['git', 'log', '-1', '--oneline', '--format="%ci"']);
            $currentRemote = $app->executeCommandOnProject($project, ['git', 'remote', 'show']);
            $remoteUrl = $app->executeCommandOnProject($project, ['git', 'config', '--get', sprintf('remote.%s.url', $currentRemote)]);
            return [$project->name, $project->path, $currentBranch, $lastCommitDate, $remoteUrl];
        }, $projects->projects),
    );

    return Command::SUCCESS;
}));

$app->addCommand(new Command('projects:create'))
    ->setAliases(['create'])
    ->setDescription('Create a new configuration file')
    ->setCode(function (SymfonyStyle $io, InputInterface $input, Application $app): int {
    /** @var App $app */

    $files = $app->getAllowedConfigPaths($input->hasOption('config') ? $input->getOption('config') : null);

    $filename = $io->choice('Where do you want to create the config file?', $files);

    if (is_file($filename)) {
        throw new \RuntimeException(sprintf('File "%s" already exists.', $filename));
    }

    $dir = dirname($filename);
    if (!is_dir($dir) && !mkdir($dir, 0755, true) && !is_dir($dir)) {
        throw new \RuntimeException(sprintf('An error occurred when creating "%s" directory.', $dir));
    }

    $defaultContent = <<<JSON
    {
    }
    JSON;

    if (false === file_put_contents($filename, $defaultContent)) {
        throw new \RuntimeException('An error occurred when creating config file.');
    }

    return Command::SUCCESS;
});

$app->addCommand(new Command('projects:add')
    ->setAliases(['add'])
    ->addArgument('name', InputArgument::OPTIONAL)
    ->addArgument('path', InputArgument::OPTIONAL)
    ->setCode(function (InputInterface $input, SymfonyStyle $io, Application $app): int {
    /** @var App $app */

    $git = $app->findExecutable('git');

    $name = $input->getArgument('name') ?: $io->ask('Project name?');
    $argPath = $input->getArgument('path');
    $argPathValidated = false;
    do {
        $path = $argPath && !$argPathValidated ? $argPath : $io->ask('Path?');
        $argPathValidated = true;

        if (!$path) {
            $io->error('Please specify a directory.');
            continue;
        }

        if (isset($_SERVER['HOME']) && str_contains($path, '~')) {
            $path = str_replace('~', $_SERVER['HOME'], $path);
        }

        if (!is_dir($path)) {
            $io->error('Specified path is not a valid directory.');
            $path = null;
            continue;
        }

        $process = new Symfony\Component\Process\Process([$git, 'status', '--porcelain'], $path);
        $exitCode = $process->run();
        if ($exitCode !== 0) {
            $io->error(sprintf('Directory %sdoes not seem to be a valid git repository.', $path));
            $path = null;
        }
    } while (!$path);

    $globalConfig = $app->getGlobalConfig();

    $globalConfig = $globalConfig->withProject(new Project($name, $path));

    $app->saveProjects($globalConfig);

    $io->success('Done!');

    return Command::SUCCESS;
}));

$app->addCommand(new Command('projects:git:fetch')
    ->setAliases(['git:fetch'])
    ->setCode(function (SymfonyStyle $io, Cursor $cursor, Application $app): int {
    /** @var App $app */

    $app->executeCommandOnAllProjects([
        $app->findExecutable('git'),
        'fetch',
        '--all',
        '--prune',
    ], $cursor);

    return Command::SUCCESS;
}));

$app->addCommand(new Command('projects:command:no-output')
    ->setAliases(['command', 'command:all'])
    ->addArgument('arguments', InputArgument::IS_ARRAY)
    ->setDescription('Run a command on all projects, only checks whether commands succeeded.')
    ->setHelp(<<<HELP
    You should add "<info>--</>" before your command to make sure options do not create conflict.
    
    For example, this command might return an error:
    
    > <info>{$PHPBIN} {$_SERVER['PHP_SELF']} projects:command:no-output git fetch --all --prune</>
    
    The reason is that the "--all" and "--prune" are options, and they will automatically be interpreted
    as options for the <comment>main</> command, not the one you delegate to projects.

    To fix this, you must run the command this way:

    > <info>{$PHPBIN} {$_SERVER['PHP_SELF']} projects:command:no-output -- git fetch --all --prune</>

    HELP
    )
    ->setCode(function (InputInterface $input, SymfonyStyle $io, Cursor $cursor, Application $app): int {
    /** @var App $app */

    $command = $input->getArgument('arguments');

    if (!is_file($command[0])) {
        $command[0] = $app->findExecutable($command[0]);
    }

    $app->executeCommandOnAllProjects($command, $cursor);

    return Command::SUCCESS;
}));

$app->run();

readonly class GlobalConfig
{
    public function __construct(
        /** @var array<Project> */
        public array $projects = [],
    ) {
    }

    public function withProject(Project $project): self
    {
        foreach ($this->projects as $existing) {
            if ($existing->name === $project->name) {
                throw new \RuntimeException('Project with same name already exists.');
            }
            if (realpath($existing->path) === realpath($project->path)) {
                throw new \RuntimeException('Project with same path already exists.');
            }
        }
        $projects = $this->projects;
        $projects[] = $project;

        return new self($projects);
    }

    public function getProject(int|string $projectName): Project
    {
        foreach ($this->projects as $project) {
            if ($projectName === $project->name) {
                return $project;
            }
        }
        throw new \RuntimeException(sprintf('Could not find project "%s".', $projectName));
    }
}

readonly class Project
{
    public function __construct(
        public string $name,
        public string $path,
    ) {
    }
}
